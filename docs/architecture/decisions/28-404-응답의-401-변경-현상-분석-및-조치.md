# 404 응답의 401 변경 현상 분석 및 조치 보고서

Date: 2025-08-17  
Status: Accepted

<br/>

## 맥락

인증된 사용자가 존재하지 않는 리소스(예: `/api/v1/feeds/{non-existent-id}`)에 GET 요청을 보낼 시, 서버로부터 **404 Not Found**가 아닌 **401 Unauthorized** 응답이 반환되는 문제가 발생했습니다.

### 문제 관찰

- **기대 동작**:  
  클라이언트는 리소스가 없음을 의미하는 404 Not Found 상태 코드를 수신하고, 이에 맞는 UI/UX(예: "게시물이 존재하지 않습니다" 알림 후 홈으로 이동)를 처리해야 합니다.

- **실제 동작**:  
  클라이언트는 인증 실패를 의미하는 401 Unauthorized 상태 코드를 수신했습니다.  
  이로 인해 프론트엔드에서는 토큰 만료로 오인하여 불필요한 토큰 재발급을 시도하거나 로그인 페이지로 리디렉션하는 등, 의도치 않은 흐름이 트리거되었습니다.

<br/>

### 원인 분석

- 해당 현상을 검토해보며 얻은 지표들은 단순 인증 정보 누락이 아닌 Spring 내부 동작과 관련된 문제임을 시사했습니다.

- **ResponseStatusException 발생**  
  서비스 계층에서 존재하지 않는 리소스에 대해  
  `new ResponseStatusException(HttpStatus.NOT_FOUND)` 예외가 정상적으로 발생합니다.

- **Spring Boot 에러 핸들러 개입**  
  Spring Boot는 발생한 예외를 감지하고, 클라이언트에게 일관된 형식의 에러 응답을 제공하기 위해 `BasicErrorController`를 사용합니다.  
  이 과정에서 서버 내부적으로 요청을 `/error` 엔드포인트로 **포워딩(Forwarding)** 합니다.  
  (_이는 클라이언트가 인지하는 리디렉션이 아닌, 서버 내부에서 처리 위임하는 Dispatch 과정입니다._)

- **Security Filter Chain 재적용**  
  `/error`로 포워딩된 내부 요청 또한 기존에 설정된 Spring Security 필터 체인의 검사를 다시 받습니다.

- **401 Unauthorized 발생**  
  현재 보안 설정은 `anyRequest().authenticated()` 규칙에 따라 모든 경로에 인증을 요구하고 있었습니다.  
  `/error` 경로에 대한 명시적인 예외 처리가 없었기 때문에, Security 필터는 이 내부 포워딩 요청을 "인증되지 않은 접근"으로 간주하여 차단하고 **401 Unauthorized** 응답을 생성했습니다.

결론적으로 최초의 **404 Not Found** 상태는 `/error` 접근 실패로 생성된 **401 Unauthorized** 상태에 의해 **덮어쓰기(override)** 되어 클라이언트에 최종 전달된 것입니다.

<br/>
<br/>

## 결정

Spring Boot의 에러 처리 메커니즘이 보안 필터에 의해 방해받지 않도록, `SecurityConfig` 설정에 `/error` 경로에 대한 요청을 허용(`permitAll`)하는 규칙을 추가했습니다.

### 수정된 SecurityFilterChain

```java
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // ... (기타 CORS, CSRF 설정)
            .authorizeHttpRequests(authorize -> authorize
                // '/error' 경로를 인증 없이 허용
                .requestMatchers("/error").permitAll()
                // 기존의 다른 경로 보안 설정은 유지
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

<br/>

## 결과

- 정상 적으로 404 응답을 반환합니다.
