# 빌드 및 배포 자동화 프로세스

Date: 2025-03-01

## 상태

적용 중

## 요약

GitHub Actions, Docker, Amazon ECR, EC2를 활용하여 자동화된 빌드 및 배포 파이프라인을 구축하였습니다.

!["CI/CD Architecture"](../src/09-빌드-및-배포-자동화-프로세스-요약.png)

#### 개요

```
  ① main 브랜치에 push 발생
  ② GitHub Actions에서 각 Docker 이미지 빌드
  ③ Amazon ECR에 이미지 푸시
  ④ EC2에 SSH 접속 → 최신 이미지 pull
  ⑤ docker-compose로 컨테이너 재시작
```

#### 이미지 구성

- **Backend**: openJDK 기반, Spring Boot `.jar` 파일 포함
- **Frontend**: Node.js 기반, Next.js 앱
- **DB**: MariaDB 공식 이미지 + volume 마운트로 데이터 지속성 확보

<br/>
<br/>

## 맥락

초기에는 **Raspberry Pi**를 활용하여 애플리케이션이 정상적으로 실행되는지를 검증하였습니다.  
이후 **AWS EC2** 환경으로 확장하면서 다음과 같은 문제들을 마주했습니다.

<br/>

### 문제 1. 반복적인 수동 배포 작업 → GitHub Actions 도입

- 수동으로 빌드 및 배포하는 과정에서 반복 작업과 오류가 빈번하게 발생했습니다.
- 이를 자동화하기 위해 GitHub Actions 기반 CI/CD 파이프라인을 도입하였고, 커밋 메시지에 `#deploy` 키워드가 포함된 경우에만 실행되도록 조건을 설정하였습니다.
- 서버 내 쉘 스크립트 자동화도 고려했지만, 브랜치 트리거 및 버전 관리 측면에서 **GitHub Actions**가 더 적합하다고 판단하였습니다.

<br/>

---

<br/>

### 문제 2. 환경 설정 및 버전 충돌 → Docker 및 Docker Compose 도입

- 라이브러리 버전 충돌 및 실행 환경 차이로 인한 문제를 해결하기 위해 Docker를 도입하였습니다.
- Backend, Frontend, DB를 각각 컨테이너화하고, `docker-compose.yml`을 통해 동일 네트워크에서 통합 실행되도록 구성하였습니다.

<br/>

---

<br/>

### 문제 3. AWS 배포 환경 선택: Elastic Beanstalk vs `EC2`

|     항목      |               EC2                |         Elastic Beanstalk         |
| :-----------: | :------------------------------: | :-------------------------------: |
| 컨테이너 구성 | 자유롭게 다중 컨테이너 구성 가능 |   기본적으로 단일 컨테이너 중심   |
|  설정 유연성  | nginx, systemd 등 자유 설정 가능 | 제한적 설정 (프록시 등 제한 있음) |
| 로그/모니터링 |          수동 설정 필요          |     CloudWatch 연동 자동 제공     |

- 본 프로젝트는 백엔드, 프론트엔드, 데이터베이스를 포함하여 3개 이상의 컨테이너를 동시에 구동해야 하므로, **Docker Compose** 기반 구성이 필요합니다.
- Elastic Beanstalk에서는 멀티 컨테이너 구성이 가능하긴 하나, Docker Compose를 직접 지원하지 않고, ECS 기반 JSON 구성 방식만 허용되므로 복잡성이 증가합니다.
- 이에 따라, 더 높은 유연성과 간결한 구성을 제공하는 `EC2 환경을 선택`하였습니다.

<br/>
<br/>

## 결정

!["CI/CD Architecture"](../src/09-빌드-및-배포-자동화-프로세스.png)

자동화 파이프라인은 다음과 같은 단계로 구성됩니다:

---

### 1단계. 로컬 개발 환경 구성 및 버전 관리

- 프로젝트 구조: `backend/`, `frontend/`, `docker-compose.yml`, `.github/workflows/ci-cd.yml`
- main 브랜치로 커밋 시 배포 여부 결정

---

### 2단계. GitHub Actions 조건부 트리거

- `#deploy` 키워드 포함 여부를 기준으로 파이프라인 실행

  ```
  if: contains(github.event.head_commit.message, '#deploy')
  ```

---

### 3단계. Docker 이미지 빌드 및 ECR 푸시

- Backend: `.jar` 빌드 후 이미지 생성

- Frontend: Next.js 앱 이미지 생성

- 생성된 이미지를 Amazon ECR에 푸시

---

### 4단계. EC2 서버 연결 및 배포 자동화

- 이전 이미지 정리 (`docker image prune`)
- 최신 이미지 pull
- `docker-compose`로 재시작

---

### 5단계. MariaDB는 외부 이미지 활용 및 데이터 지속성 유지

- Docker Hub 공식 이미지 사용
- volume 마운트를 통해 데이터 영속성 확보

<br/>
<br/>

## 결과

### ① GitHub Actions, ECR, EC2 간 역할 분리 및 자동화 체계 정립

- 전체 배포 과정을 자동화함으로써, 사람의 개입 없이 안정적인 운영이 가능해졌습니다.
- 구성요소별 역할:
  - **GitHub Actions**: 트리거 감지, 빌드, SSH 배포 실행
  - **ECR**: 이미지 저장소, 생명주기 정책 (최대 6개 보관)
  - **EC2**: 컨테이너 실행 환경, 자동 정리 및 재시작 담당

<br/>

---

<br/>

### ② 이미지 누적에 따른 자원 낭비 문제 해결

- **EC2 내부 정리**: GitHub Actions 내부에서 배포 직전 docker image prune 실행

- **ECR 저장소 정리**: 생명주기 정책 설정으로 태그 기준 최신 6개만 유지

<br/>

---

<br/>

### ③ 장애 복구 및 빌드 안정성 향상

- 로그 수집: CloudWatch 연동을 통해 docker logs를 대체
- 알림 연동: 향후 Slack, 이메일 기반 경고 시스템 도입 예정
- 캐시 전략: .m2, node_modules 디렉토리 캐싱 도입 예정
