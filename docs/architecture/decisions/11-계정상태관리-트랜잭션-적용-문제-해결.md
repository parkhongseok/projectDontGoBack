# OAuth2UserService에서의 트랜잭션 적용 문제 해결

Date: 2025-05-07

## 상태

적용 중

## 맥락

본 프로젝트에서는 OAuth2 로그인 시점에 유저의 상태를 판별하고, 필요에 따라 이를 복원하거나 변경하는 기능이 요구되었습니다.
그러나 다음과 같은 기술적 제약으로 인해 변경 사항이 DB에 반영되지 않는 문제가 발생하였습니다.

### ① 문제 발생 위치

- 상태 변경 로직이 `OAuth2UserService.loadUser()` 메서드 내부에 포함되어 있었습니다.

- 해당 메서드는 Spring Security의 필터 체인 내부에서 실행되며, DispatcherServlet 이전에 호출되기 때문에
  Spring AOP 기반의 `@Transactional`이 적용되지 않는 컨텍스트입니다.

### ② 문제의 원인

- `user.setCurrentStatusHistory(...)` 등 `setter`를 통해 엔티티 필드를 변경하더라도,  
  트랜잭션이 적용되지 않으므로 flush 또는 commit이 발생하지 않습니다.

- 결과적으로 **Hibernate의 변경 감지(dirty checking)는 작동**하였지만,  
  **실제로 DB에 반영되지 않아** 상태 이력이 저장되지 않는 문제가 발생하였습니다.

<br/>
<br/>

## 결정

이 문제를 해결하기 위해 다음과 같은 전략을 적용하였습니다.

### 1. 상태 변경 로직의 책임 분리를 통한 해결

| 항목      | 내용                                                           |
| --------- | -------------------------------------------------------------- |
| 위치      | `OAuth2UserService.loadUser()` 내부 → 별도 서비스로 분리       |
| 클래스    | `AccountStatusHistoryService`                                  |
| 처리 방식 | 트랜잭션 보장 범위 내에서의 상태 변경 및 명시적 저장 처리 적용 |

- `AccountStatusHistoryService`를 생성하여, 상태 변경 및 이력 추가를 담당하게 하였습니다.
- 해당 서비스 메서드에 `@Transactional`을 적용하고, 변경된 엔티티를 `save()`로 명시적으로 저장하도록 구성하였습니다.

<br/>

```java
@Transactional
public User updateStatus(User user, AccountStatus newStatus, String reason) {
    currentStatusHistory.setEndedAt(now);
    accountStatusHistoryRepository.save(currentStatusHistory); // 명시적 저장

    AccountStatusHistory newStatusHistory = ...
    accountStatusHistoryRepository.save(newStatusHistory);

    user.setCurrentStatusHistory(newStatusHistory);
    return userRepository.save(user); // 명시적 저장
}
```

- `OAuth2UserService`에서는 단순히 이 메서드를 호출만 하도록 역할을 최소화하였습니다.

<br/>
<br/>

## 결과

본 조치를 통해 다음과 같은 개선 효과를 확인할 수 있었습니다.

- 트랜잭션 외부에서 변경한 객체가 DB에 반영되지 않는 문제를 해결하였습니다.

- Spring Security 인증 흐름 내에서 트랜잭션이 적용되지 않는 한계를 우회할 수 있었습니다.

- `setter`만으로 처리되던 상태 변경 로직을 명시적 저장과 트랜잭션 처리로 안정화하였습니다.

- Spring AOP의 동작 시점, 트랜잭션 전파 범위, Hibernate의 `flush` 타이밍에 대한 이해를 기반으로 설계를
  개선하였습니다.

결과적으로 **OAuth2 인증 흐름의 안정성과 데이터 무결성을 동시에 확보**할 수 있게 되었습니다.
